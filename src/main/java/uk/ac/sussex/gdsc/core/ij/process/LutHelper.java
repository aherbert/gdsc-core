/*-
 * #%L
 * Genome Damage and Stability Centre ImageJ Core Package
 *
 * Contains code used by:
 *
 * GDSC ImageJ Plugins - Microscopy image analysis
 *
 * GDSC SMLM ImageJ Plugins - Single molecule localisation microscopy (SMLM)
 * %%
 * Copyright (C) 2011 - 2021 Alex Herbert
 * %%
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public
 * License along with this program.  If not, see
 * <http://www.gnu.org/licenses/gpl-3.0.html>.
 * #L%
 */

package uk.ac.sussex.gdsc.core.ij.process;

import ij.process.LUT;
import java.awt.Color;
import uk.ac.sussex.gdsc.core.utils.MathUtils;
import uk.ac.sussex.gdsc.core.utils.ValidationUtils;

/**
 * Contains functions for ImageJ LUTs.
 *
 * @see LUT
 */
public final class LutHelper {

  /** The size of an 8-bit look-up table. */
  private static final int LUT_TABLE_8BIT_SIZE = 256;
  /** List of the LUT names. */
  private static final String[] luts;

  /**
   * The LUT Colour.
   */
  public enum LutColour {

    /** The red hot LUT. */
    RED_HOT("Red-Hot"),

    /** The ice LUT. */
    ICE("Ice"),

    /** The rainbow LUT. */
    RAINBOW("Rainbow"),

    /** The fire LUT. */
    FIRE("Fire"),

    /** The fire light LUT. */
    FIRE_LIGHT("FireLight"),

    /** The fire glow LUT. */
    FIRE_GLOW("FireGlow"),

    /** The black body LUT. */
    BLACK_BODY("BlackBody"),

    /** The Kindlmann LUT. */
    KINDLMANN("Kindlmann"),

    /** The extended Kindlmann LUT. */
    EXTENDED_KINDLMANN("Extended-Kindlmann"),

    /** The red yellow LUT. */
    RED_YELLOW("Red-Yellow"),

    /** The red LUT. */
    RED("Red"),

    /** The green LUT. */
    GREEN("Green"),

    /** The blue LUT. */
    BLUE("Blue"),

    /** The cyan LUT. */
    CYAN("Cyan"),

    /** The magenta LUT. */
    MAGENTA("Magenta"),

    /** The yellow LUT. */
    YELLOW("Yellow"),

    /** The red blue LUT. */
    RED_BLUE("Red-Blue"),

    /** The intense LUT. */
    INTENSE("Intense") {
      @Override
      public boolean isDistinct() {
        return true;
      }
    },

    /** The pimp LUT. */
    PIMP("Pimp") {
      @Override
      public boolean isDistinct() {
        return true;
      }
    },

    /** The pimp light LUT. */
    PIMP_LIGHT("PimpLight") {
      @Override
      public boolean isDistinct() {
        return true;
      }
    },

    /** The distinct LUT. */
    DISTINCT("Distinct") {
      @Override
      public boolean isDistinct() {
        return true;
      }
    },

    /** The red cyan LUT. */
    RED_CYAN("Red-Cyan"),

    /** The grays LUT. */
    GRAYS("Grays");

    private final String nameString;

    LutColour(String name) {
      nameString = name;
    }

    @Override
    public String toString() {
      return getName();
    }

    /**
     * Gets the name.
     *
     * @return the name
     */
    public String getName() {
      return nameString;
    }

    /**
     * Checks if is a distinct colour set.
     *
     * <p>This is when all colours should be distinct to the human eye.
     *
     * @return true, if is distinct
     */
    public boolean isDistinct() {
      return false;
    }

    /**
     * Get the LUT colour for the given number.
     *
     * @param lut the lut number
     * @return the lut colour (or null)
     */
    public static LutColour forNumber(int lut) {
      final LutColour[] values = LutColour.values();
      if (lut >= 0 && lut < values.length) {
        return values[lut];
      }
      return null;
    }

    /**
     * Get the LUT colour for the given name. The case is ignored when matching the name.
     *
     * @param name the name (case insensitive)
     * @return the lut colour (or null)
     */
    public static LutColour forName(String name) {
      for (final LutColour value : LutColour.values()) {
        if (value.nameString.equalsIgnoreCase(name)) {
          return value;
        }
      }
      return null;
    }
  }

  static {
    final LutColour[] l = LutColour.values();
    luts = new String[l.length];
    for (int i = 0; i < l.length; i++) {
      luts[i] = l[i].getName();
    }
  }

  /** No public instances. */
  private LutHelper() {}


  /**
   * Gets a list of the LUT names.
   *
   * @return the LUT names
   */
  public static String[] getLutNames() {
    return luts.clone();
  }

  /**
   * Create a colour LUT so that all colours from 1-255 are distinct.
   *
   * @return The LUT
   */
  public static LUT getColorModel() {
    // For legacy compatibility. There are now other choices in the LutColour enum for distinct
    // colours
    return createLut(LutColour.DISTINCT);
  }

  /**
   * Build a custom LUT. Does not include black at zero.
   *
   * @param lut The LUT to create
   * @return the LUT
   * @see #createLut(LutColour, boolean)
   */
  public static LUT createLut(int lut) {
    if (lut >= 0 && lut < luts.length) {
      return createLut(LutColour.forNumber(lut), false);
    }
    return null;
  }

  /**
   * Build a custom LUT. Does not include black at zero.
   *
   * @param lut The LUT to create
   * @return the LUT
   * @see #createLut(LutColour, boolean)
   */
  public static LUT createLut(LutColour lut) {
    return createLut(lut, false);
  }

  /**
   * Build a custom LUT.
   *
   * @param lut The LUT to create
   * @param includeBlack Set to true to include black at index 0
   * @return the LUT
   */
  public static LUT createLut(LutColour lut, boolean includeBlack) {
    // Direct LUTs
    switch (lut) {
      case BLACK_BODY:
        return blackBody(includeBlack);
      case KINDLMANN:
        return kindlmann(includeBlack);
      case EXTENDED_KINDLMANN:
        return extendedKindlmann(includeBlack);
      case INTENSE:
        return intense(includeBlack);
      case PIMP:
        return pimp(includeBlack);
      case PIMP_LIGHT:
        return pimpLight(includeBlack);
      case DISTINCT:
        return distinct(includeBlack);
      default:
        break;
    }

    // Interpolated
    final byte[] reds = new byte[256];
    final byte[] greens = new byte[256];
    final byte[] blues = new byte[256];
    int numberOfColours;
    switch (lut) {
      // Note: RED_HOT is the default at the end

      case ICE:
        numberOfColours = ice(reds, greens, blues);
        break;
      case RAINBOW:
        numberOfColours = rainbow(reds, greens, blues);
        break;
      case FIRE:
        numberOfColours = fire(reds, greens, blues);
        break;
      case FIRE_LIGHT:
        numberOfColours = firelight(reds, greens, blues);
        break;
      case FIRE_GLOW:
        numberOfColours = fireglow(reds, greens, blues);
        break;
      case RED_YELLOW:
        numberOfColours = setColours(reds, greens, blues, Color.red, Color.yellow);
        break;
      case RED_BLUE:
        numberOfColours = setColours(reds, greens, blues, Color.red, Color.blue);
        break;
      case RED_CYAN:
        numberOfColours = setColours(reds, greens, blues, Color.red, Color.cyan);
        break;
      case RED:
        numberOfColours = setColours(reds, greens, blues, Color.red);
        break;
      case GREEN:
        numberOfColours = setColours(reds, greens, blues, Color.green);
        break;
      case BLUE:
        numberOfColours = setColours(reds, greens, blues, Color.blue);
        break;
      case CYAN:
        numberOfColours = setColours(reds, greens, blues, Color.cyan);
        break;
      case MAGENTA:
        numberOfColours = setColours(reds, greens, blues, Color.magenta);
        break;
      case YELLOW:
        numberOfColours = setColours(reds, greens, blues, Color.yellow);
        break;
      case GRAYS:
        numberOfColours = grays(reds, greens, blues);
        break;
      case RED_HOT:
      default:
        numberOfColours = setColours(reds, greens, blues, Color.red, Color.yellow, Color.WHITE);
        break;
    }
    interpolate(reds, greens, blues, numberOfColours, includeBlack);
    return new LUT(reds, greens, blues);
  }

  /**
   * Copied from ij.plugin.LutLoader.
   *
   * @param reds the reds
   * @param greens the greens
   * @param blues the blues
   * @return the number of colours
   */
  private static int ice(byte[] reds, byte[] greens, byte[] blues) {
    final int[] r = {0, 0, 0, 0, 0, 0, 19, 29, 50, 48, 79, 112, 134, 158, 186, 201, 217, 229, 242,
        250, 250, 250, 250, 251, 250, 250, 250, 250, 251, 251, 243, 230};
    final int[] g = {156, 165, 176, 184, 190, 196, 193, 184, 171, 162, 146, 125, 107, 93, 81, 87,
        92, 97, 95, 93, 93, 90, 85, 69, 64, 54, 47, 35, 19, 0, 4, 0};
    final int[] b = {140, 147, 158, 166, 170, 176, 209, 220, 234, 225, 236, 246, 250, 251, 250, 250,
        245, 230, 230, 222, 202, 180, 163, 142, 123, 114, 106, 94, 84, 64, 26, 27};
    for (int i = 0; i < r.length; i++) {
      reds[i] = (byte) r[i];
      greens[i] = (byte) g[i];
      blues[i] = (byte) b[i];
    }
    return r.length;
  }

  private static int rainbow(byte[] reds, byte[] greens, byte[] blues) {
    // Using HSV vary the Hue from 300 (magenta) to Red (0)
    int index = 0;
    for (int h = 300; h >= 0; h -= 2) {
      final Color c = Color.getHSBColor(h / 360.0f, 1, 1);
      reds[index] = (byte) c.getRed();
      greens[index] = (byte) c.getGreen();
      blues[index] = (byte) c.getBlue();
      index++;
    }
    return index;
  }

  /**
   * Copied from ij.plugin.LutLoader.
   *
   * @param reds the reds
   * @param greens the greens
   * @param blues the blues
   * @return the number of colours
   */
  private static int fire(byte[] reds, byte[] greens, byte[] blues) {
    final int[] r = {0, 0, 1, 25, 49, 73, 98, 122, 146, 162, 173, 184, 195, 207, 217, 229, 240, 252,
        255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255};
    final int[] g = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 35, 57, 79, 101, 117, 133, 147, 161,
        175, 190, 205, 219, 234, 248, 255, 255, 255, 255};
    final int[] b = {0, 61, 96, 130, 165, 192, 220, 227, 210, 181, 151, 122, 93, 64, 35, 5, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 35, 98, 160, 223, 255};
    for (int i = 0; i < r.length; i++) {
      reds[i] = (byte) r[i];
      greens[i] = (byte) g[i];
      blues[i] = (byte) b[i];
    }
    return r.length;
  }

  /**
   * Adapted from ij.plugin.LutLoader to remove the dark colours.
   *
   * @param reds the reds
   * @param greens the greens
   * @param blues the blues
   * @return the number of colours
   */
  private static int firelight(byte[] reds, byte[] greens, byte[] blues) {
    final int[] r = { // 0, 0, 1, 25, 49,
        73, 98, 122, 146, 162, 173, 184, 195, 207, 217, 229, 240, 252, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255};
    final int[] g = { // 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 14, 35, 57, 79, 101, 117, 133, 147, 161, 175, 190, 205, 219, 234,
        248, 255, 255, 255, 255};
    final int[] b = { // 0, 61, 96, 130, 165,
        192, 220, 227, 210, 181, 151, 122, 93, 64, 35, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 35, 98,
        160, 223, 255};
    for (int i = 0; i < r.length; i++) {
      reds[i] = (byte) r[i];
      greens[i] = (byte) g[i];
      blues[i] = (byte) b[i];
    }
    return r.length;
  }

  /**
   * Adapted from ij.plugin.LutLoader to remove the dark colours and near white colours.
   *
   * @param reds the reds
   * @param greens the greens
   * @param blues the blues
   * @return the number of colours
   *
   */
  private static int fireglow(byte[] reds, byte[] greens, byte[] blues) {
    final int[] r = { // 0, 0, 1, 25, 49,
        73, 98, 122, 146, 162, 173, 184, 195, 207, 217, 229, 240, 252, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255
        // , 255, 255, 255
    };
    final int[] g = { // 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 14, 35, 57, 79, 101, 117, 133, 147, 161, 175, 190, 205, 219, 234,
        248, 255
        // , 255, 255, 255
    };
    final int[] b = { // 0, 61, 96, 130, 165,
        192, 220, 227, 210, 181, 151, 122, 93, 64, 35, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 35, 98
        // , 160, 223, 255
    };
    for (int i = 0; i < r.length; i++) {
      reds[i] = (byte) r[i];
      greens[i] = (byte) g[i];
      blues[i] = (byte) b[i];
    }
    return r.length;
  }

  private static int setColours(byte[] reds, byte[] greens, byte[] blues, Color... colours) {
    int index = 0;
    if (colours.length == 1) {
      reds[index] = (byte) (colours[0].getRed() / 2);
      greens[index] = (byte) (colours[0].getGreen() / 2);
      blues[index] = (byte) (colours[0].getBlue() / 2);
      index++;
    }

    for (final Color colour : colours) {
      reds[index] = (byte) colour.getRed();
      greens[index] = (byte) colour.getGreen();
      blues[index] = (byte) colour.getBlue();
      index++;
    }
    return index;
  }

  // LUTs with distinct colours.

  // Finding distinct colours using the Hue, Chroma, Lightness scales to set constraints.
  // http://tools.medialab.sciences-po.fr/iwanthue/
  // Colours were generated for 256 distinct colours using the force-vector method and then randomly
  // ordered.

  // Intense = H 0:360, C 20-100, L 15-80
  private static LUT intense(boolean includeBlack) {
    final byte[] rgb = {-91, 54, 0, -1, -118, -88, -67, 0, 40, 56, -98, 0, -8, -76, -59, 1, -56,
        -75, -105, 0, 25, -110, 0, 46, 59, 24, 62, -14, -65, 53, 83, 3, 8, 64, 93, 0, -23, -67, -94,
        -80, -48, -105, 117, 95, 125, 53, 24, 76, 111, -34, 100, -2, 0, 31, 0, 61, -86, -125, 0,
        -95, 121, 65, 0, 0, 100, -57, -57, 0, 80, -1, 80, -91, 6, -30, -110, -72, 82, -1, -1, -87,
        -73, 60, 112, 0, -62, -49, 54, -1, -114, -127, 98, 0, -101, -128, 48, 0, 0, 84, -114, -124,
        -38, -128, -1, 120, -98, -101, 118, 0, 123, 82, 72, 20, -76, 0, -61, -93, -1, 0, -79, 126,
        -19, -64, 82, 112, 0, 27, 73, 56, -31, -89, 0, -70, 46, 53, 0, -14, -108, -1, 87, -57, 0, 1,
        33, -108, -6, -71, 126, 59, 1, 102, -69, -124, -1, -20, -69, -81, -114, -45, -56, 1, -51,
        -106, 103, -116, -1, -94, 0, 47, 68, -37, -49, 98, -43, -16, -33, -79, -1, -96, 110, -1,
        -128, -48, -13, 109, -101, -1, -127, 0, 116, 0, -123, 30, 84, 0, 85, 0, -110, -45, -101,
        -42, 119, 0, -118, 68, 0, -94, -117, 33, 41, 0, -46, 65, -12, -1, 122, -79, -38, 40, 0, -50,
        -53, 73, 0, 66, -105, -55, -117, 0, -46, 0, 104, -104, 95, 0, -89, -119, -89, 88, 0, 44,
        -128, -36, 67, 92, 0, 0, 2, -105, -71, 0, 49, -91, -124, 108, 0, 0, -50, 49, 0, 61, 41, 32,
        -38, -23, 38, 23, 100, -56, 102, -1, -1, -100, 112, 106, 0, 76, -1, 114, -52, -6, 0, -52,
        115, 46, -36, 0, 85, -94, -1, -94, -35, 99, 120, -1, 68, 12, 70, -45, -104, -1, -69, -107,
        127, 0, 2, -116, 1, 103, 94, -16, -82, 0, 2, -94, -99, -107, -48, 0, -74, -45, 38, 34, 109,
        0, -55, 84, 0, 0, -80, 109, 0, -78, 69, -102, -114, 0, 67, 24, 23, 0, 91, 71, 0, 78, 21,
        -33, 0, 57, -1, 67, 83, 0, 60, 12, 1, 114, 90, 77, 2, 57, -1, 113, 114, -120, 121, -1, 110,
        -78, -1, -103, -95, 125, -120, 24, 0, 45, -58, -1, 1, 109, -12, 41, 64, 0, 107, 44, 0, 1,
        -112, -100, 0, -115, 101, 59, 47, 0, 83, 39, 0, -1, -113, 102, -1, 117, 90, 83, 55, 0, -1,
        -75, 81, -1, 98, 98, -80, 0, -100, -82, -73, -1, 0, -83, 78, 1, -47, 85, 0, 50, -127, -103,
        0, 119, 0, -125, 102, 0, 97, 97, -69, 101, 0, 45, 32, 64, -1, -93, 91, -66, 0, 25, 0, 83,
        -78, 0, 47, 28, -52, 127, 0, -62, -76, -1, -89, 68, 0, 116, -38, -101, 74, 14, 38, -1, 107,
        -3, 2, -117, -25, 78, 0, -123, -24, -82, -1, 94, 112, 0, 0, 76, -27, -1, 64, -116, -1, 99,
        -111, 0, 64, 111, 0, 117, -109, 106, -106, 0, 0, -125, -22, -1, -114, 40, -1, -83, -82, 105,
        96, 0, 0, -48, -11, -111, -43, -89, 67, 77, 0, -53, -55, -118, -1, -124, -22, 82, 42, 54,
        -85, -43, 2, -10, 31, -37, -118, 0, -72, -1, 117, -62, -35, 0, -109, -31, 106, -1, 124, 0,
        52, -1, 76, -61, -1, 123, -8, -119, -84, -1, 0, 48, 89, -109, -38, 11, 107, 0, 115, 17, 44,
        1, 1, -110, -65, -1, -126, 61, -33, -61, -114, -46, 66, 0, -12, -67, 98, 0, 112, -28, -77,
        0, 98, 71, 22, 10, -1, 83, 42, -81, 0, 116, 0, -64, -24, -40, -55, 51, -69, -49, 125, -70,
        0, -122, -17, 0, 118, -63, 0, -70, -33, 0, -80, -3, 0, 99, 0, 54, -38, 0, 88, -38, -22, 76,
        -3, -83, -44, 67, -1, -87, -121, -53, 106, 0, 52, 0, -98, -29, 0, -122, 0, 101, 61, 85, 74,
        0, 92, 0, 32, 116, 0, 8, -92, 118, -123, 1, -105, -11, 0, 26, -95, 99, 100, -1, -1, -70, 30,
        -117, 0, -106, 63, 29, 3, -21, -62, 0, 21, 36, 74, 117, -39, -77, -109, -39, 70, 90, -125,
        0, 2, 23, 117, 90, -74, -1, 0, 88, 13, -1, 67, 117, -6, -75, -80, -30, -71, -26, 40, -30,
        127, 84, 44, 42, 1, -71, -72, -12, 28, 0, -39, -59, -125, 125, 66, -16, 1, 121, -83, -1,
        -83, 49, -69, -49, 106, 0, 34, 93, -86, -56, -8, -1, 16, 75, -1, -114, -101, -113, 0, 69,
        -44, -68, -9, 0, -114, 13};
    return fromRgbValues(rgb, includeBlack);
  }

  // Pimp = H 0:360, C 30-100, L 25-70
  private static LUT pimp(boolean includeBlack) {
    final byte[] rgb = {110, 20, 88, 18, 69, 14, 78, -62, 41, -81, 0, 30, -22, -107, -122, 45, 23,
        -77, 1, -83, -123, -72, -83, 69, -39, 0, 115, 104, 39, 16, -125, 0, 93, 0, -75, -93, -46,
        118, -1, 62, -113, 0, 26, -123, 0, -52, -104, -33, -78, 115, 0, -1, 97, -46, 105, 14, 109,
        -98, -115, -1, -3, -119, -115, -13, 126, -11, -81, 119, -98, -74, 111, 115, -117, 0, 22, 69,
        -62, 86, 88, -65, 109, 5, 71, 3, 1, 76, -56, -22, 0, -75, 99, 42, 33, 124, 46, 0, -85, 0,
        115, -1, 93, 99, -1, 46, -99, -57, -89, 93, 103, -81, -2, 65, 63, 0, -1, 46, -83, 117, 23,
        16, -86, -80, 111, -73, 107, 0, -14, 119, -1, -33, -100, 101, -4, -123, -82, 107, 51, -33,
        -6, -127, -46, -118, -70, 19, 109, -69, -126, 94, 34, 100, 1, 108, -90, -19, 43, -29, -101,
        112, -1, -49, -120, 0, -34, 0, 63, -7, 0, -88, -89, -100, 0, 46, 44, -111, -19, 106, -1, -1,
        119, 101, -108, 112, 70, -81, 0, 46, -25, -101, 17, 99, -69, -96, 0, -81, -3, 0, 102, 73,
        -1, 118, 78, 0, 95, -81, -38, 75, 0, -1, -124, -107, -83, 96, -1, 1, -83, 74, -77, -115, 97,
        0, 98, 34, -18, 116, 0, -1, 43, -63, 37, 50, -121, 118, 18, 38, 113, 31, 0, 1, 111, 34, 59,
        81, -4, -122, 72, 0, -5, 15, 18, 38, -102, 0, 104, -111, 100, -1, -119, 107, -76, -101, -1,
        0, -112, 63, -92, -76, 39, -86, 49, 0, 110, 45, 0, 1, 61, 116, -1, 115, 41, 0, 76, 125, 30,
        55, 123, -73, -107, -57, -58, -114, 112, -113, 0, 67, 127, 62, 80, -79, 0, 106, 64, 123, 0,
        -40, -114, -107, 0, -103, -46, 125, 69, 102, 1, -82, -35, 117, -121, 0, 84, 61, 17, 106, 8,
        -61, -1, 101, 124, -119, 107, 0, 0, 87, -61, 12, -86, -1, 89, 41, 90, -1, 113, -112, -46, 0,
        101, 53, 57, 103, -126, 92, 0, -43, -92, 17, 123, 75, 0, -1, 50, -43, 112, 25, 59, -5, -121,
        -93, -122, 88, -127, -9, -111, 87, -31, 1, -117, -110, 0, -124, -90, 0, 70, 114, -66, 38,
        -18, 0, -47, -61, 75, -3, -1, 95, -102, -89, -79, 92, -1, 117, 123, -49, 0, -106, 119, -67,
        69, -51, 0, 46, -21, -119, -36, 107, 36, 28, -127, 0, 53, 0, -122, 110, 88, -91, -1, -92,
        125, 0, 97, -65, 83, -58, 0, -53, -104, 0, -81, -45, 0, 83, 57, 108, 0, -57, 42, 0, -128,
        64, -18, -7, -115, 124, -52, -106, -22, 95, 48, 0, -128, -99, -1, -93, 98, 89, -15, -107,
        67, -42, -93, 48, 55, 50, 120, 120, 0, -118, 125, -102, 0, -44, 0, 69, 97, 91, -1, 0, -83,
        3, 1, 83, -16, 87, 70, -15, 118, 4, 74, 1, -80, 110, -1, 66, 94, -32, -99, 79, 67, 99, 0,
        24, 69, 26, -1, 93, 66, -112, 0, 46, 95, 104, -1, -26, 93, 0, 67, 44, 123, -36, 60, -16, 1,
        -107, 117, -95, 92, 98, -42, -109, -29, -1, -127, -68, 114, 111, -93, -1, 117, -35, -111,
        -73, 91, -120, -74, -123, -79, 107, 123, -66, 0, -79, 0, 105, -15, 0, 112, -21, 1, 52, -78,
        -18, -110, 0, -50, -92, 101, -1, 93, -88, -59, -89, 111, 0, 122, -19, -61, -91, 0, 59, -64,
        -111, -101, 0, 40, 0, 101, -113, -1, -124, 54, -1, -123, 19, -79, -95, 107, -79, -94, -33,
        86, 87, -120, 66, 34, -107, -73, 0, 61, -81, 74, 0, 0, 65, -39, 0, 83, 47, 0, -70, -54, 1,
        106, -52, 127, 118, -1, -105, -73, 45, -98, 0, 96, -118, -73, 114, 126, 0, 20, -2, -113, 2,
        -103, 0, 1, 81, 32, -124, 0, -115, -20, -107, -88, -15, 95, 90, 0, 90, 56, 0, 101, 53, 31,
        -54, 0, 24, 1, -108, 44, 95, 40, 74, 1, 53, -43, 48, -114, -1, -71, -84, 88, 105, 93, 43,
        -35, -117, -8, -110, 39, 0, -42, -97, 122, -21, -111, -92, -67, 0, -98, 101, 0, -86, -51,
        89, -1, -115, 59, 0, 71, -71, 0, -119, -118, 0, 0, 123, 70, -71, -103, 0, -18, -108, 112,
        -72, 0, -110, 121, 0, 101, -1, 41, 96, -1, 61, -125, 61, 81, 0, -85, 85, 0, -82, 5, 0, 106,
        35, 44, 67, 51, 100, 0, -74, -44, 0, 71, -114, -92, 0, 84, 99, 81, 0};
    return fromRgbValues(rgb, includeBlack);
  }

  // Pimp = H 0:360, C 30-100, L 35-90
  private static LUT pimpLight(boolean includeBlack) {
    final byte[] rgb = {19, 70, -60, -1, -100, -16, -83, 110, -1, 70, 73, -97, -89, 0, 97, -40, -18,
        58, 88, 68, -100, -122, -92, 114, -24, -73, 0, -1, 98, -90, -1, -105, 115, -1, -110, 79,
        -66, 0, 21, 107, 59, -100, -79, 97, -1, -52, 0, 64, -65, 0, -108, -115, 54, 48, -1, 125,
        123, -116, -97, -43, -109, 57, 0, -8, -27, 45, -128, 23, -50, -72, 70, 0, 2, -110, -31, -52,
        0, -120, 114, 104, 0, 0, -39, -104, -1, 52, -60, 0, 113, 94, 90, 52, -34, -16, 0, -101, 1,
        -106, 123, -1, 115, 58, 113, -121, -69, 113, 75, 15, 58, -1, -104, 0, -93, 121, -45, -74, 0,
        -42, -67, -120, -1, 44, -126, 2, -58, -33, 84, -66, 0, -108, 21, -121, 0, 118, -64, -120,
        92, 58, -60, 48, 0, 103, 64, -114, 0, -57, -54, 42, 94, 22, -1, 85, 30, 65, 102, -106, -122,
        0, -71, -122, 61, 30, -1, 79, -108, -47, 76, -2, 84, 58, -68, -113, -5, 102, -73, -112, -1,
        123, 69, 14, -69, 0, 51, 119, 57, -124, -26, 112, -1, -36, 1, 92, -118, -11, -29, -1, -96,
        49, -26, -112, -1, 79, 89, 38, -113, 54, 21, -26, -77, -1, 0, -46, 85, -33, 0, 1, 99, 122,
        0, -98, 32, 47, -1, 101, -7, -1, -45, -115, 41, -103, 0, -58, 0, -82, 122, 125, 0, -1, 99,
        111, 1, -92, -18, -1, -111, -71, 24, -1, -79, -24, 0, 57, -4, -32, -109, 114, -2, 124, -1,
        111, -34, 118, -38, -1, 47, -5, -17, -112, -35, 0, 126, -2, 81, -83, -78, -1, -54, 0, 117,
        -83, 0, 60, 115, 43, -80, 0, -95, 90, -81, -9, 84, -69, -104, 0, -3, 46, -29, -69, -61, -4,
        121, 47, -100, -1, -85, 119, -40, 99, 0, -34, -23, -100, 114, 111, -94, 49, 92, 48, -1, 24,
        -49, -1, 91, 62, 68, -47, 0, -102, 109, 73, 0, -8, 112, 95, -90, -1, -124, 52, 112, 1, -107,
        91, -57, -114, 0, 2, -42, -61, 1, 68, -36, -91, 4, 73, -128, 91, 0, -45, 0, -50, -62, 42,
        -31, -32, -107, -93, -8, 1, -124, 86, -98, 0, -103, -10, -83, -120, 40, -119, -81, -97, 105,
        -50, -15, 7, 2, 111, -61, -55, -68, 0, 40, 81, -107, -107, 102, 0, 79, -27, 44, -112, 40,
        107, 2, -78, -22, -41, -101, -1, -1, -109, -6, -1, -58, 12, -98, -104, -1, -1, -85, -87,
        -74, -22, 0, -1, 127, -25, -1, 118, 0, 96, 85, 0, -14, -26, 89, -1, -43, 71, -20, -26, 120,
        -107, -7, -119, -31, 0, 108, -61, -18, -70, -128, -121, -1, -1, -119, -53, -1, 15, 96, 0,
        84, -81, -73, -10, 59, -1, 121, -50, 67, 100, 0, 0, -62, 119, 0, -81, 72, 87, -1, 97, -50,
        111, -1, -10, 96, 0, -1, 24, -105, -55, 102, 0, 1, -50, -85, 89, -8, -9, 126, 66, 44, 0,
        -125, 49, 75, 66, -20, 0, -81, 17, -48, -18, 119, 127, 91, -1, -108, 47, 58, -66, 0, 43,
        -92, 22, 28, -91, 0, -93, -115, -84, 0, 110, 113, -1, 0, 95, -45, -1, -88, 85, 67, 90, 19,
        -106, 40, 82, -26, -71, -23, -61, -128, 115, 73, -112, 0, 0, 93, -112, -111, -52, 0, 116,
        -118, 0, 28, 95, 38, -112, -9, -68, -1, 117, -97, 0, 115, 71, -1, 59, 68, -90, 82, 0, -14,
        0, 79, -54, -15, 95, -56, 85, -1, 0, -95, 28, -19, -85, -1, -11, 0, 108, -2, -31, 108, -88,
        0, -55, 18, -126, -1, -1, -99, -47, 1, -106, -114, -20, 53, 0, -103, 17, 119, -113, 0, -88,
        -96, -7, 103, -113, 110, 0, 82, 67, -91, 0, 78, -80, -1, -94, -119, -25, 1, -59, 112, -92,
        0, 85, 75, -126, 66, 109, 68, -36, -91, -125, 71, 126, 0, -18, -98, 0, -1, -82, 101, -61,
        -62, 0, -21, -87, 0, -1, 110, -122, -125, 57, -24, -80, 0, 124, -54, -82, -1, 108, 68, 113,
        -82, 127, -1, -1, -62, 127, -1, -56, 86, -114, 77, 75, -104, -128, -77, -1, -70, -21, -19,
        -27, -115, 0, -57, -19, 0, -37, 106, -72, -14, -102, 0, 123, -26, -1, -65, -119, -1, -116,
        33, -104, 87, 0, -1, 109, -29, -72, 0, -55, 1, -121, -70, 2, 94, -26, -93, 35, 0, 112, -98,
        -1, -1, 127, 108, -24, -117, 0, -66, -111, 105, 0, -111, -108, -89, 109, -111, -92, -93, 0,
        -1, 74, 68, 61, -3, -48};
    return fromRgbValues(rgb, includeBlack);
  }

  // This was produced using http://phrogz.net/css/distinct-colors.html
  private static LUT distinct(boolean includeBlack) {
    final byte[] rgb = {0, 0, 0, -1, 0, 0, -103, -121, 115, 76, -39, 54, 0, -120, -1, -127, 105,
        -116, -14, 0, 0, -1, -86, 0, 0, 51, 0, 0, 102, -65, -52, 0, -1, -90, 0, 0, -65, -128, 0,
        127, -1, -111, 0, 75, -116, -72, 54, -39, 51, 0, 0, 115, 77, 0, 83, -90, 94, 0, 48, 89, -26,
        -128, -1, -1, -128, -128, 76, 51, 0, 38, 77, 43, -128, -60, -1, 46, 26, 51, -103, 77, 77,
        51, 34, 0, -113, -65, -106, -65, -31, -1, 71, 0, 77, 76, 38, 38, -27, -84, 57, 0, -116, 37,
        77, 90, 102, -123, 35, -116, 51, 26, 26, -103, 115, 38, 0, 89, 24, 0, 102, -1, 99, 51, 102,
        -1, -65, -65, -1, -43, -128, 0, -1, 102, 0, 61, -103, -68, -113, -65, 115, 86, 86, -78,
        -107, 89, 115, -26, -95, 0, 20, 51, -1, 0, -18, 64, 48, 48, 102, 85, 51, -65, -1, -39, -128,
        -77, -1, -1, -65, -5, 76, 10, 0, -52, -69, -103, 115, -103, -126, 83, 116, -90, 77, 57, 75,
        -1, 89, 64, -1, -52, 0, 77, 102, 87, 57, 80, 115, -77, 0, -113, -65, 67, 48, -90, -123, 0,
        0, -52, 109, -103, -83, -52, 115, 0, 92, 115, 40, 29, 102, 82, 0, 0, -128, 68, 105, 119,
        -116, 64, 0, 51, -39, 123, 108, -39, -72, 54, 0, 51, 27, 0, 68, -1, -26, 57, -61, 115, 65,
        57, 76, 65, 19, 26, 102, 66, 0, 48, -77, -1, -128, -27, -52, -96, -103, -52, -72, 102, 83,
        -90, 127, 0, 34, -128, -65, 96, -84, -39, 58, 0, 127, 115, 64, -103, -52, -76, 0, 24, 89,
        77, 38, 69, 127, 34, 0, -1, -14, -65, 0, -1, -86, 51, 92, -52, -1, 0, -86, 89, 24, 0, -103,
        -111, 115, 0, -77, 119, 29, 52, 115, -103, 0, 102, 51, 14, 0, 102, 97, 77, 115, -26, -65,
        19, 34, 77, 89, 0, 60, -1, 115, 64, 64, 61, 48, 0, -1, -52, -128, -94, -1, -103, 77, -128,
        -90, 75, 41, -1, -18, 0, 0, -128, 102, 32, 40, 64, 115, 86, 105, -1, -94, -128, -103, -113,
        0, 0, 77, 61, -65, -48, -1, -1, 0, -120, -65, 121, 96, 115, 107, 0, 13, 51, 43, 57, 62, 77,
        -78, 0, 95, -116, 89, 70, 51, 48, 13, 57, 115, 103, 0, 27, -52, 127, 0, 68, 76, 48, 38, -1,
        -9, -128, -65, -1, -14, 0, 8, 64, 51, 0, 27, -1, -48, -65, -65, -68, -113, 57, 77, 73, 102,
        116, -52, -39, 54, -115, -103, 125, 115, -18, -1, 0, 0, -1, -18, -113, -106, -65, -1, -128,
        -60, -1, 102, 0, -89, -77, 0, 0, -77, -89, 0, 0, -1, 115, 57, 88, -65, 77, 0, 59, 64, 0,
        115, -26, -34, 0, 0, -103, 51, 26, 39, -116, 56, 0, -96, -90, 83, 77, -103, -108, 0, 0,
        -116, -1, -65, -31, 64, 26, 0, 74, 77, 38, -103, -52, -55, 0, 0, -128, -90, 124, -110, -1,
        -116, 64, 102, -128, 0, 38, 51, 50, 0, 0, 102, -1, 0, 102, -65, 105, 48, 71, 89, 0, 0, -18,
        -1, -128, -128, -1, -103, 0, 61, 127, 70, 32, -61, -26, 57, 0, -77, -65, 77, 77, -103, 102,
        0, 41, 89, 49, 22, -27, -1, -128, 0, -125, -116, -65, -65, -1, 76, 19, 42, -1, -77, -128,
        103, 115, 57, 0, 60, 64, 105, 105, -116, -52, 102, -113, -65, -122, 96, -14, -1, -65, 51,
        99, 102, 29, 26, 51, -1, 0, 68, -116, 98, 70, -86, -1, 0, 115, -106, -103, 121, 96, -65,
        -90, 0, 44, 51, 36, 26, 110, -90, 0, 0, -52, -1, 48, 38, 77, 76, 0, 20, -1, -39, -65, -86,
        -52, 102, 0, 102, -128, 126, 57, -26, -52, 51, 92, -65, -93, -113, -116, -103, 115, 48, -93,
        -65, 84, 38, -103, -1, -128, -94, 115, 98, 86, 34, 64, 0, 22, 76, 89, 49, 22, 89, -103, 77,
        97, 64, 54, 48, -115, -39, 54, -128, -26, -1, -77, -128, -1, -39, -93, -79, -1, -120, 0,
        117, -103, 77, -65, -14, -1, 80, 57, 115, 89, 67, 73, -65, 102, 0, 39, 51, 26, 0, -86, -1,
        -93, -113, -65, -39, 0, 29, -116, 75, 0, -76, -52, -103, 0, -128, -65, 87, 77, 102, -116, 0,
        19, 102, 54, 0, 68, 77, 57, 0, 94, -116, 43, 38, 51, 102, 0, 14, 64, 34, 0, 102, -1, 0, 0,
        51, 77, -120, 0, -1, -39, 54, 76};
    return fromRgbValues(rgb, includeBlack);
  }

  // https://www.kennethmoreland.com/color-advice/

  // 2D
  // "When pseudocoloring is applied to the flat surface of the image, you do not have to contend
  // with 3D shading. In this case, you are free to use the entire range of brightness from
  // completely dark to full white. These color maps take advantage of that extra range."

  private static LUT blackBody(boolean includeBlack) {
    final byte[] rgb = {0, 0, 0, 3, 1, 1, 7, 2, 1, 10, 3, 2, 13, 4, 2, 16, 5, 3, 18, 6, 3, 20, 7, 4,
        22, 8, 4, 24, 9, 5, 26, 10, 5, 27, 11, 6, 29, 11, 6, 30, 12, 7, 32, 13, 8, 33, 14, 8, 34,
        15, 9, 36, 15, 9, 37, 16, 10, 38, 16, 10, 40, 17, 11, 41, 17, 11, 43, 18, 12, 44, 18, 12,
        46, 18, 13, 47, 19, 13, 49, 19, 14, 50, 19, 14, 52, 20, 15, 54, 20, 15, 55, 20, 15, 57, 21,
        16, 58, 21, 16, 60, 21, 16, 62, 22, 17, 63, 22, 17, 65, 22, 17, 66, 23, 18, 68, 23, 18, 70,
        23, 18, 71, 24, 19, 73, 24, 19, 75, 24, 19, 76, 25, 20, 78, 25, 20, 80, 25, 20, 81, 25, 20,
        83, 26, 21, 85, 26, 21, 86, 26, 21, 88, 26, 21, 90, 27, 22, 91, 27, 22, 93, 27, 22, 95, 27,
        22, 97, 28, 23, 98, 28, 23, 100, 28, 23, 102, 28, 23, 104, 29, 24, 105, 29, 24, 107, 29, 24,
        109, 29, 24, 111, 29, 25, 112, 30, 25, 114, 30, 25, 116, 30, 25, 118, 30, 26, 119, 30, 26,
        121, 31, 26, 123, 31, 26, 125, 31, 27, 127, 31, 27, -128, 31, 27, -126, 31, 27, -124, 32,
        28, -122, 32, 28, -120, 32, 28, -119, 32, 28, -117, 32, 29, -115, 32, 29, -113, 32, 29,
        -111, 33, 29, -109, 33, 30, -108, 33, 30, -106, 33, 30, -104, 33, 31, -102, 33, 31, -100,
        33, 31, -98, 33, 31, -96, 33, 32, -95, 34, 32, -93, 34, 32, -91, 34, 32, -89, 34, 33, -87,
        34, 33, -85, 34, 33, -83, 34, 33, -81, 34, 34, -79, 34, 34, -78, 34, 34, -77, 36, 34, -76,
        38, 34, -75, 40, 33, -74, 42, 33, -73, 44, 33, -72, 45, 33, -71, 47, 32, -70, 49, 32, -69,
        50, 32, -68, 52, 31, -67, 53, 31, -66, 55, 31, -65, 56, 31, -64, 58, 30, -63, 59, 30, -62,
        61, 30, -61, 62, 29, -60, 64, 29, -59, 65, 28, -58, 66, 28, -57, 68, 28, -56, 69, 27, -55,
        71, 27, -54, 72, 26, -53, 73, 26, -52, 75, 25, -51, 76, 25, -50, 77, 24, -49, 79, 24, -48,
        80, 23, -47, 82, 23, -46, 83, 22, -45, 84, 21, -44, 85, 21, -43, 87, 20, -42, 88, 19, -41,
        89, 19, -40, 91, 18, -39, 92, 17, -38, 93, 16, -37, 95, 15, -36, 96, 14, -35, 97, 13, -34,
        98, 12, -33, 100, 11, -32, 101, 9, -31, 102, 8, -30, 104, 7, -29, 105, 5, -29, 107, 5, -29,
        109, 6, -28, 110, 7, -28, 112, 7, -28, 114, 8, -28, 116, 8, -27, 118, 9, -27, 119, 10, -27,
        121, 10, -27, 123, 11, -27, 124, 12, -26, 126, 12, -26, -128, 13, -26, -126, 14, -26, -125,
        14, -26, -123, 15, -26, -121, 15, -25, -120, 16, -25, -118, 17, -25, -116, 17, -25, -115,
        18, -25, -113, 19, -25, -111, 19, -25, -110, 20, -24, -108, 21, -24, -106, 21, -24, -105,
        22, -24, -103, 22, -24, -102, 23, -24, -100, 24, -24, -98, 24, -24, -97, 25, -24, -95, 26,
        -24, -94, 26, -23, -92, 27, -23, -90, 27, -23, -89, 28, -23, -87, 29, -23, -86, 29, -23,
        -84, 30, -23, -82, 30, -23, -81, 31, -23, -79, 32, -23, -78, 32, -23, -76, 33, -23, -75, 34,
        -23, -73, 34, -23, -71, 35, -23, -70, 35, -23, -68, 36, -23, -67, 37, -23, -65, 37, -23,
        -64, 38, -23, -62, 38, -23, -61, 39, -23, -59, 40, -23, -57, 40, -23, -56, 41, -24, -54, 42,
        -24, -53, 42, -24, -51, 43, -24, -50, 43, -24, -48, 44, -24, -47, 45, -24, -45, 45, -24,
        -43, 46, -24, -42, 47, -24, -40, 47, -25, -39, 48, -25, -37, 48, -25, -36, 49, -25, -34, 50,
        -25, -33, 50, -25, -31, 51, -26, -30, 52, -26, -28, 52, -26, -27, 53, -25, -25, 60, -23,
        -25, 69, -22, -24, 78, -20, -23, 87, -19, -22, 94, -18, -21, 102, -16, -20, 109, -15, -20,
        117, -14, -19, 124, -13, -18, -125, -11, -17, -119, -10, -16, -112, -9, -15, -105, -8, -15,
        -98, -7, -14, -92, -7, -13, -85, -6, -12, -79, -5, -11, -72, -4, -10, -66, -4, -9, -59, -3,
        -8, -53, -3, -7, -46, -2, -7, -40, -2, -6, -33, -2, -5, -27, -1, -4, -20, -1, -3, -14, -1,
        -2, -7, -1, -1, -1};
    return fromRgbValues(rgb, includeBlack);
  }

  private static LUT kindlmann(boolean includeBlack) {
    final byte[] rgb = {0, 0, 0, 5, 0, 4, 9, 0, 8, 13, 1, 13, 17, 1, 16, 20, 1, 20, 22, 1, 23, 25,
        1, 26, 27, 1, 29, 29, 2, 32, 30, 2, 35, 31, 2, 38, 32, 2, 42, 33, 2, 45, 34, 2, 48, 35, 2,
        51, 36, 3, 54, 37, 3, 57, 37, 3, 60, 38, 3, 63, 38, 3, 66, 38, 3, 68, 39, 3, 71, 39, 4, 74,
        39, 4, 77, 39, 4, 80, 39, 4, 83, 39, 4, 86, 39, 4, 89, 39, 4, 93, 39, 5, 96, 39, 5, 99, 38,
        5, 102, 38, 5, 106, 37, 5, 109, 37, 5, 112, 36, 6, 116, 35, 6, 119, 34, 6, 123, 33, 6, 126,
        32, 6, -127, 32, 6, -124, 31, 6, -120, 30, 7, -117, 29, 7, -114, 28, 7, -111, 27, 7, -108,
        26, 7, -105, 25, 7, -102, 25, 7, -99, 24, 8, -96, 24, 8, -93, 20, 8, -90, 15, 8, -86, 8, 9,
        -82, 8, 12, -81, 8, 15, -81, 8, 19, -81, 8, 22, -81, 8, 25, -81, 8, 28, -82, 8, 32, -83, 8,
        35, -84, 8, 38, -86, 8, 41, -88, 8, 43, -90, 8, 46, -91, 8, 49, -93, 8, 51, -96, 8, 53, -98,
        8, 56, -100, 7, 58, -102, 7, 60, -104, 7, 62, -107, 7, 64, -109, 7, 66, -111, 7, 68, -113,
        7, 70, -115, 7, 71, -117, 7, 73, -119, 7, 75, -121, 6, 76, -123, 6, 78, -124, 6, 80, -126,
        6, 81, -128, 6, 83, 127, 6, 84, 125, 6, 86, 123, 6, 87, 122, 6, 88, 120, 6, 90, 119, 6, 91,
        118, 6, 93, 116, 6, 94, 115, 5, 95, 114, 6, 96, 113, 5, 98, 112, 5, 99, 110, 5, 100, 109, 5,
        102, 108, 5, 103, 107, 5, 104, 106, 5, 105, 105, 5, 107, 104, 5, 108, 103, 5, 109, 102, 5,
        110, 101, 5, 112, 100, 5, 113, 99, 5, 114, 98, 6, 115, 96, 6, 117, 95, 6, 118, 94, 6, 119,
        92, 6, 120, 91, 6, 122, 89, 6, 123, 88, 6, 124, 86, 6, 125, 84, 6, 127, 83, 6, -128, 81, 6,
        -127, 79, 6, -126, 77, 6, -124, 75, 6, -123, 74, 7, -122, 72, 6, -121, 70, 7, -119, 67, 7,
        -118, 65, 7, -117, 63, 7, -116, 61, 7, -114, 59, 7, -113, 56, 7, -112, 54, 7, -111, 52, 7,
        -109, 49, 7, -108, 47, 7, -107, 44, 7, -106, 42, 7, -105, 39, 7, -103, 37, 7, -102, 34, 8,
        -101, 31, 8, -100, 29, 8, -99, 26, 8, -97, 23, 8, -96, 20, 8, -95, 18, 8, -94, 15, 8, -93,
        12, 8, -91, 10, 8, -90, 8, 12, -89, 8, 15, -88, 8, 17, -87, 8, 18, -86, 8, 20, -85, 8, 22,
        -83, 8, 24, -82, 8, 26, -81, 8, 29, -80, 8, 32, -79, 9, 35, -78, 9, 38, -77, 9, 41, -76, 9,
        45, -75, 9, 48, -74, 9, 52, -73, 9, 56, -72, 9, 59, -71, 9, 63, -70, 9, 67, -69, 9, 71, -68,
        9, 75, -67, 9, 79, -66, 9, 83, -66, 9, 87, -65, 9, 91, -64, 9, 95, -63, 9, 99, -63, 9, 103,
        -62, 9, 107, -61, 9, 111, -60, 9, 116, -60, 9, 120, -59, 9, 124, -58, 10, -128, -58, 10,
        -123, -57, 10, -119, -57, 10, -115, -56, 10, -111, -56, 10, -106, -55, 10, -102, -55, 10,
        -98, -54, 10, -93, -54, 10, -89, -54, 10, -85, -53, 10, -81, -53, 10, -76, -53, 10, -72,
        -52, 10, -68, -52, 10, -63, -52, 10, -59, -51, 10, -55, -51, 10, -51, -51, 10, -47, -51, 10,
        -42, -51, 10, -38, -51, 11, -33, -51, 11, -28, -51, 11, -23, -51, 11, -19, -51, 11, -13,
        -51, 12, -10, -52, 57, -9, -51, 86, -8, -51, 105, -7, -50, 119, -7, -49, -125, -6, -49,
        -115, -6, -48, -107, -6, -47, -99, -5, -46, -93, -5, -45, -87, -5, -44, -82, -5, -42, -77,
        -4, -41, -72, -4, -40, -68, -4, -39, -64, -4, -38, -61, -4, -36, -57, -4, -35, -54, -3, -34,
        -51, -3, -32, -48, -3, -31, -45, -3, -30, -43, -3, -29, -40, -3, -27, -38, -3, -26, -35, -3,
        -24, -33, -2, -23, -31, -2, -22, -29, -2, -20, -27, -2, -19, -25, -2, -18, -23, -2, -16,
        -21, -2, -15, -19, -2, -14, -17, -2, -12, -15, -2, -11, -13, -2, -9, -11, -1, -8, -10, -1,
        -7, -8, -1, -5, -6, -1, -4, -4, -1, -2, -3, -1, -1, -1};
    return fromRgbValues(rgb, includeBlack);
  }

  private static LUT extendedKindlmann(boolean includeBlack) {
    final byte[] rgb = {0, 0, 0, 5, 0, 4, 9, 0, 9, 13, 1, 13, 16, 1, 17, 19, 1, 21, 22, 1, 24, 24,
        1, 27, 26, 1, 30, 27, 2, 34, 28, 2, 38, 29, 2, 42, 29, 2, 46, 30, 2, 50, 30, 3, 53, 30, 3,
        57, 30, 3, 61, 29, 3, 65, 29, 3, 68, 28, 3, 72, 27, 4, 75, 27, 4, 79, 26, 4, 82, 25, 4, 85,
        24, 4, 88, 23, 4, 92, 22, 5, 95, 21, 5, 98, 20, 5, 101, 19, 5, 103, 18, 5, 106, 18, 5, 109,
        17, 5, 111, 14, 5, 115, 8, 6, 119, 6, 8, 120, 6, 11, 120, 6, 15, 119, 6, 18, 118, 6, 22,
        116, 5, 25, 114, 5, 28, 112, 5, 31, 109, 5, 33, 107, 5, 36, 104, 5, 38, 101, 5, 40, 99, 5,
        42, 96, 5, 44, 94, 4, 46, 91, 4, 48, 89, 4, 49, 87, 4, 51, 85, 4, 52, 83, 4, 54, 81, 4, 55,
        79, 4, 57, 77, 4, 58, 76, 4, 59, 74, 3, 61, 73, 3, 62, 71, 3, 63, 70, 3, 65, 69, 3, 66, 67,
        3, 67, 66, 3, 68, 65, 3, 69, 64, 3, 71, 63, 3, 72, 61, 4, 73, 60, 4, 74, 58, 4, 75, 56, 4,
        77, 55, 4, 78, 53, 4, 79, 51, 4, 80, 49, 4, 81, 47, 4, 82, 45, 4, 84, 43, 4, 85, 41, 4, 86,
        39, 4, 87, 36, 4, 88, 34, 4, 89, 31, 4, 91, 29, 4, 92, 26, 5, 93, 24, 5, 94, 21, 5, 95, 18,
        5, 96, 15, 5, 97, 13, 5, 98, 10, 5, 100, 8, 5, 101, 6, 6, 102, 5, 8, 103, 5, 10, 104, 5, 11,
        105, 5, 13, 106, 5, 15, 107, 5, 17, 108, 5, 20, 109, 5, 22, 110, 5, 26, 111, 5, 29, 112, 5,
        32, 112, 5, 36, 113, 5, 40, 114, 5, 43, 115, 6, 47, 116, 6, 51, 116, 6, 55, 117, 6, 59, 118,
        6, 63, 118, 6, 67, 119, 6, 71, 119, 6, 76, 120, 6, 80, 120, 6, 84, 121, 6, 88, 121, 6, 92,
        122, 6, 97, 122, 6, 101, 122, 6, 105, 123, 6, 109, 123, 6, 113, 123, 6, 118, 123, 6, 122,
        123, 6, 126, 123, 6, -126, 123, 6, -121, 123, 7, -117, 123, 7, -112, 123, 7, -107, 122, 7,
        -102, 122, 7, -96, 121, 8, -91, 120, 8, -85, 119, 8, -79, 118, 8, -73, 117, 9, -67, 115, 9,
        -60, 113, 9, -54, 111, 10, -47, 108, 10, -40, 105, 10, -34, 102, 11, -27, 98, 11, -20, 94,
        11, -13, 90, 12, -12, 91, 27, -11, 92, 37, -11, 94, 46, -11, 96, 52, -10, 98, 58, -10, 99,
        63, -10, 101, 67, -10, 103, 71, -10, 105, 74, -10, 107, 77, -9, 109, 79, -9, 111, 83, -9,
        112, 87, -9, 114, 91, -9, 115, 96, -8, 117, 101, -8, 118, 106, -8, 120, 112, -8, 121, 118,
        -7, 122, 123, -7, 123, -127, -7, 125, -121, -7, 126, -115, -7, 127, -109, -7, -127, -103,
        -7, -126, -98, -7, -125, -92, -7, -124, -87, -7, -123, -81, -7, -122, -76, -7, -121, -70,
        -7, -119, -65, -7, -118, -60, -7, -117, -55, -6, -116, -50, -6, -115, -45, -6, -114, -40,
        -6, -113, -35, -6, -112, -31, -6, -111, -26, -6, -110, -21, -6, -109, -17, -6, -108, -13,
        -6, -107, -8, -8, -104, -6, -11, -101, -6, -14, -97, -6, -17, -94, -5, -20, -91, -5, -22,
        -88, -5, -24, -85, -5, -26, -83, -5, -27, -80, -5, -29, -78, -5, -30, -76, -5, -31, -74, -5,
        -32, -72, -4, -32, -70, -4, -33, -68, -4, -33, -66, -4, -34, -65, -4, -34, -63, -4, -34,
        -61, -4, -34, -60, -4, -33, -58, -4, -33, -57, -4, -33, -55, -4, -32, -54, -4, -32, -52, -3,
        -31, -51, -3, -30, -49, -3, -30, -48, -3, -29, -47, -3, -28, -45, -3, -27, -44, -3, -27,
        -43, -3, -26, -41, -3, -25, -40, -3, -25, -38, -3, -25, -37, -3, -24, -35, -3, -24, -34, -3,
        -24, -32, -3, -24, -31, -2, -23, -29, -2, -23, -28, -2, -23, -26, -2, -23, -25, -2, -23,
        -23, -2, -23, -22, -2, -22, -20, -2, -22, -19, -2, -22, -17, -2, -21, -16, -2, -21, -14, -2,
        -20, -13, -2, -19, -11, -2, -19, -10, -2, -18, -9, -2, -17, -7, -2, -16, -6, -2, -14, -5,
        -2, -13, -4, -2, -11, -3, -1, -8, -2, -1, -5, -1, -1, -1, -1, -1};
    return fromRgbValues(rgb, includeBlack);
  }

  /**
   * Create the LUT from RGB values. There must be 3x256 values in the input array.
   *
   * @param rgb the rgb values
   * @param includeBlack if true set the first index to black
   * @return the lut
   */
  private static LUT fromRgbValues(byte[] rgb, boolean includeBlack) {
    final byte[] r = new byte[256];
    final byte[] g = new byte[256];
    final byte[] b = new byte[256];
    for (int i = (includeBlack) ? 1 : 0; i < 256; i++) {
      r[i] = (byte) (rgb[i * 3 + 0] & 255);
      g[i] = (byte) (rgb[i * 3 + 1] & 255);
      b[i] = (byte) (rgb[i * 3 + 2] & 255);
    }
    return new LUT(r, g, b);
  }

  /**
   * Copied from ij.plugin.LutLoader
   *
   * @param reds the reds
   * @param greens the greens
   * @param blues the blues
   * @return the number of colours
   */
  private static int grays(byte[] reds, byte[] greens, byte[] blues) {
    for (int i = 0; i < 256; i++) {
      reds[i] = (byte) i;
      greens[i] = (byte) i;
      blues[i] = (byte) i;
    }
    return 256;
  }

  /**
   * Adapted from ij.plugin.LutLoader.
   *
   * @param reds the reds
   * @param greens the greens
   * @param blues the blues
   * @param numberOfColours the number of colours
   * @param includeBlack Set to true to include black at index zero
   */
  private static void interpolate(byte[] reds, byte[] greens, byte[] blues, int numberOfColours,
      boolean includeBlack) {
    // numberOfColours should be at least 2 and max 256.
    if (numberOfColours == LUT_TABLE_8BIT_SIZE) {
      if (includeBlack) {
        reds[0] = greens[0] = blues[0] = 0;
      }
      return;
    }

    // Interpolate so that 0/1 is the first colour (depending on black)
    // and 255 is the final colour.

    // Copy the original input colours
    final byte[] r = new byte[numberOfColours];
    final byte[] g = new byte[numberOfColours];
    final byte[] b = new byte[numberOfColours];
    System.arraycopy(reds, 0, r, 0, numberOfColours);
    System.arraycopy(greens, 0, g, 0, numberOfColours);
    System.arraycopy(blues, 0, b, 0, numberOfColours);

    int total = 256;
    int index = 0;
    if (includeBlack && (reds[0] != 0 || greens[0] != 0 || blues[0] != 0)) {
      // Not black so reduce the interpolation range and make an explicit black.
      total = 255;
      index = 1;
      reds[0] = greens[0] = blues[0] = 0;
    }

    // Bug fix
    // ij.plugin.LutLoader used (numberOfColours / 256.0).
    // This made all the colours from 128-255 the same for 2 colour interpolation as i1==i2.
    // Here we interpolate linearly from min index to max index so that the full colour
    // is only used at the first/last index.
    final double scale = (double) (numberOfColours - 1) / (total - 1);
    for (int i = 0; i < total; i++, index++) {
      final int i1 = (int) (i * scale);
      int i2 = i1 + 1;
      if (i2 == numberOfColours) {
        i2 = numberOfColours - 1;
      }
      final double fraction = i * scale - i1;
      reds[index] = (byte) ((1.0 - fraction) * (r[i1] & 255) + fraction * (r[i2] & 255));
      greens[index] = (byte) ((1.0 - fraction) * (g[i1] & 255) + fraction * (g[i2] & 255));
      blues[index] = (byte) ((1.0 - fraction) * (b[i1] & 255) + fraction * (b[i2] & 255));
    }
  }

  /**
   * Get a colour from the LUT. The LUT is assumed to have a 256 colours in the table.
   *
   * @param lut the lut
   * @param index The position in the LUT (from 0-255)
   * @return a colour
   */
  public static Color getColour(LUT lut, int index) {
    return new Color(lut.getRGB(MathUtils.clip(0, 255, index)));
  }

  /**
   * Get a colour from the LUT. If the total is equal or less than 256 then the lut can be assumed
   * for an 8-bit image. If above 256 then the colour is assumed for a 16-bit image and so the
   * position is scaled linearly to 0-255 to find the colour. The uses the
   * {@link #getColour(LUT, int, int, int)} method.
   *
   * @param lut the lut
   * @param index The position in the series (zero-based)
   * @param total The total in the series (exclusive)
   * @return a colour
   */
  public static Color getColour(LUT lut, int index, int total) {
    if (total <= LUT_TABLE_8BIT_SIZE) {
      // Assume 8-bit image
      return getColour(lut, index);
    }

    // Use behaviour for 16-bit images. Maximum is inclusive.
    return getColour(lut, index, 0, total - 1);
  }

  /**
   * Get a colour from the LUT. Used for 16-bit images. The output LUT index is in the range
   * {@code [0, 255]}:
   *
   * <pre>
   * 255 * (value - minimum) / (maximum - minimum)
   * </pre>
   *
   * @param lut the lut
   * @param value the value
   * @param minimum the minimum display value inclusive (mapped to 0)
   * @param maximum the maximum display value inclusive (mapped to 255)
   * @return a colour
   */
  public static Color getColour(LUT lut, int value, int minimum, int maximum) {
    ValidationUtils.checkArgument(minimum <= maximum, "Minimum %d not less than maximum %d",
        minimum, maximum);
    // Logic adapted from ShortProcessor.create8BitImage.
    // Clip to 16-bit range
    final int min = Math.max(0, minimum);
    if (value <= min) {
      return new Color(lut.getRGB(0));
    }
    // Transform to 0-255 8-bit range
    final int shiftedValue = value - min;
    final int max = Math.min(65535, maximum);
    final double scale = 255.0 / (max - min);
    final int scaledValue = Math.min(255, (int) Math.round(shiftedValue * scale));

    return new Color(lut.getRGB(scaledValue));
  }

  /**
   * Get a colour from the LUT. Used for 32-bit images.
   *
   * @param lut the lut
   * @param value the value
   * @param minimum the minimum display value inclusive (mapped to 0)
   * @param maximum the maximum display value inclusive (mapped to 255)
   * @return a colour
   */
  public static Color getColour(LUT lut, float value, float minimum, float maximum) {
    checkRange(minimum, maximum);
    // Logic adapted from FloatProcessor.create8BitImage
    if (value <= minimum) {
      return new Color(lut.getRGB(0));
    }
    final float shiftedValue = value - minimum;
    final float scale = 255f / (maximum - minimum);
    final int scaledValue = Math.min(255, Math.round(shiftedValue * scale));

    return new Color(lut.getRGB(scaledValue));
  }

  /**
   * Check the minimum is less than or equal to the maximum so there is a range.
   *
   * @param minimum the minimum
   * @param maximum the maximum
   */
  static void checkRange(float minimum, float maximum) {
    ValidationUtils.checkArgument(minimum <= maximum, "Minimum %f not less than maximum %f",
        minimum, maximum);
  }

  /**
   * Get a colour from the LUT ignoring zero. If the total is equal or less than 255 then the lut
   * can be assumed for an 8-bit image. The index is clipped to the range 0-254 and mapped to the
   * value 1-255.
   *
   * <p>If above 255 then the colour is assumed for a 16-bit image and so the position is scaled
   * linearly to 1-255 to find the colour. The uses the
   * {@link #getNonZeroColour(LUT, int, int, int)} method.
   *
   * @param lut the lut
   * @param index The position in the series (zero-based)
   * @param total The total in the series (exclusive)
   * @return a colour
   */
  public static Color getNonZeroColour(LUT lut, int index, int total) {
    if (total < LUT_TABLE_8BIT_SIZE) {
      // Assume 8-bit image
      return new Color(lut.getRGB(1 + MathUtils.clip(0, 254, index)));
    }

    // Use behaviour for 16-bit images. Maximum is inclusive.
    return getNonZeroColour(lut, index, 1, total - 1);
  }

  /**
   * Get a colour from the LUT ignoring zero. Used for 16-bit images. The output LUT index is in the
   * range {@code [0, 255]}:
   *
   * <pre>
   * 1 + 254 * (value - minimum) / (maximum - minimum)
   * </pre>
   *
   * @param lut the lut
   * @param value the value
   * @param minimum the minimum display value inclusive (mapped to 1)
   * @param maximum the maximum display value inclusive (mapped to 255)
   * @return a colour
   */
  public static Color getNonZeroColour(LUT lut, int value, int minimum, int maximum) {
    ValidationUtils.checkArgument(minimum <= maximum, "Minimum %d not less than maximum %d",
        minimum, maximum);
    // Logic adapted from ShortProcessor.create8BitImage.
    // Clip to 16-bit range
    final int min = Math.max(0, minimum);
    if (value <= min) {
      return new Color(lut.getRGB(1));
    }
    // Transform to 1-255 8-bit range
    final int shiftedValue = value - min;
    final int max = Math.min(65535, maximum);
    final double scale = 254.0 / (max - min);
    final int scaledValue = Math.min(255, 1 + (int) Math.round(shiftedValue * scale));

    return new Color(lut.getRGB(scaledValue));
  }

  /**
   * Get a colour from the LUT ignoring zero. Used for 32-bit images.
   *
   * @param lut the lut
   * @param value the value
   * @param minimum the minimum display value inclusive (mapped to 1)
   * @param maximum the maximum display value inclusive (mapped to 255)
   * @return a colour
   */
  public static Color getNonZeroColour(LUT lut, float value, float minimum, float maximum) {
    checkRange(minimum, maximum);
    // Logic adapted from FloatProcessor.create8BitImage
    if (value <= minimum) {
      return new Color(lut.getRGB(1));
    }
    final float shiftedValue = value - minimum;
    final float scale = 254f / (maximum - minimum);
    final int scaledValue = Math.min(255, 1 + Math.round(shiftedValue * scale));

    return new Color(lut.getRGB(scaledValue));
  }

  /**
   * Provide mapping for values to the range of 0-255 for a 8-bit image.
   */
  public interface LutMapper {
    /**
     * Map the value to a value between 0 and 255.
     *
     * @param value the value
     * @return the mapped value
     */
    int map(float value);

    /**
     * Map the value to a value between 0 and 255.
     *
     * @param value the value
     * @return the mapped value
     */
    float mapf(float value);

    /**
     * Gets the colour.
     *
     * @param lut the lut
     * @param value the value
     * @return the colour
     */
    Color getColour(LUT lut, float value);

    /**
     * Gets the min value output by {@link #map(float)}.
     *
     * @return the min value
     */
    int getMin();

    /**
     * Gets the max value output by {@link #map(float)}.
     *
     * @return the max value
     */
    int getMax();
  }

  /**
   * Provide no mapping.
   */
  public static class NullLutMapper implements LutMapper {
    private static final float MAX = 255;

    /**
     * Rounds the input to the nearest int and truncates to the range 0-255.
     *
     * @param value the value
     * @return the int
     */
    @Override
    public int map(float value) {
      if (value < 0) {
        return 0;
      }
      if (value > MAX) {
        return 255;
      }
      return Math.round(value);
    }

    /**
     * Provide no mapping (returns the input value).
     *
     * @param value the value
     * @return the float
     */
    @Override
    public float mapf(float value) {
      return value;
    }

    @Override
    public Color getColour(LUT lut, float value) {
      return new Color(lut.getRGB(map(value)));
    }

    @Override
    public int getMin() {
      return 0;
    }

    @Override
    public int getMax() {
      return 255;
    }
  }

  /**
   * Provide a default map for a value to the range 0-255. Functionality will match that of rendered
   * 32-bit images.
   */
  public static class DefaultLutMapper extends NullLutMapper {
    /** The minimum. */
    final float minimum;
    /** The scale. */
    final float scale;

    /**
     * Instantiates a new default LUT mapper.
     *
     * @param minimum the minimum
     * @param maximum the maximum
     */
    public DefaultLutMapper(float minimum, float maximum) {
      checkRange(minimum, maximum);
      this.minimum = minimum;
      scale = 255f / (maximum - minimum);
    }

    @Override
    public int map(float value) {
      if (value <= minimum) {
        return 0;
      }
      final float scaledValue = value - minimum;
      return Math.min(255, Math.round(scaledValue * scale));
    }

    @Override
    public float mapf(float value) {
      return map(value);
    }
  }

  /**
   * Provide a default map for a value to the range 1-255.
   */
  public static class NonZeroLutMapper extends NullLutMapper {
    /** The minimum. */
    final float minimum;
    /** The scale. */
    final float scale;

    /**
     * Instantiates a new non zero LUT mapper.
     *
     * @param minimum the minimum
     * @param maximum the maximum
     */
    public NonZeroLutMapper(float minimum, float maximum) {
      checkRange(minimum, maximum);
      this.minimum = minimum;
      scale = 254f / (maximum - minimum);
    }

    @Override
    public int map(float value) {
      if (value <= minimum) {
        return 1;
      }
      final float scaledValue = value - minimum;
      return Math.min(255, 1 + Math.round(scaledValue * scale));
    }

    @Override
    public float mapf(float value) {
      return map(value);
    }

    @Override
    public int getMin() {
      return 1;
    }
  }
}
